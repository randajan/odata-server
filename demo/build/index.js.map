{
  "version": 3,
  "sources": ["../../src/class/ODataServer.js", "../../src/class/Router.js", "../../src/index.js"],
  "sourcesContent": ["import { EventEmitter } from \"events\";          //const Emitter = require('events').EventEmitter\r\nimport url from \"url\";                            //const url = require('url')\r\nimport { Buffer } from \"safe-buffer\";             //const Buffer = require('safe-buffer').Buffer\r\nimport { Router } from \"./Router\";\r\n// const metadata = require('./metadata.js')\r\n// const collections = require('./collections.js')\r\n// const query = require('./query.js')\r\n// const insert = require('./insert.js')\r\n// const update = require('./update.js')\r\n// const remove = require('./remove.js')\r\n// const prune = require('./prune.js')\r\n\r\n\r\nexport class ODataServer extends EventEmitter {\r\n  constructor(serviceUrl) {\r\n    this.serviceUrl = serviceUrl\r\n\r\n    this.cfg = {\r\n      serviceUrl,\r\n      afterRead: function () {},\r\n      beforeQuery: function (col, query, req, cb) { cb() },\r\n      executeQuery: ODataServer.prototype.executeQuery.bind(this),\r\n      beforeInsert: function (col, query, req, cb) { cb() },\r\n      executeInsert: ODataServer.prototype.executeInsert.bind(this),\r\n      beforeUpdate: function (col, query, update, req, cb) { cb() },\r\n      executeUpdate: ODataServer.prototype.executeUpdate.bind(this),\r\n      beforeRemove: function (col, query, req, cb) { cb() },\r\n      executeRemove: ODataServer.prototype.executeRemove.bind(this),\r\n      base64ToBuffer: ODataServer.prototype.base64ToBuffer.bind(this),\r\n      bufferToBase64: ODataServer.prototype.bufferToBase64.bind(this),\r\n      pruneResults: ODataServer.prototype.pruneResults.bind(this),\r\n      addCorsToResponse: ODataServer.prototype.addCorsToResponse.bind(this)\r\n    }\r\n  }\r\n\r\n  handle(req, res) {\r\n    if (!this.cfg.serviceUrl && !req.protocol) {\r\n      throw new Error('Unable to determine service url from the express request or value provided in the ODataServer constructor.')\r\n    }\r\n  \r\n    function escapeRegExp (str) {\r\n      return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\r\n    }\r\n  \r\n    // If mounted in express, trim off the subpath (req.url) giving us just the base path\r\n    const path = (req.originalUrl || '/').replace(new RegExp(escapeRegExp(req.url) + '$'), '')\r\n    this.cfg.serviceUrl = this.serviceUrl ? this.serviceUrl : (req.protocol + '://' + req.get('host') + path)\r\n  \r\n    const prefix = url.parse(this.cfg.serviceUrl).pathname // eslint-disable-line\r\n    if (!this.router || (prefix !== this.router.prefix)) {\r\n      this.router = new Router(prefix)\r\n      this._initializeRoutes()\r\n    }\r\n  \r\n    this.router.dispatch(req, res)\r\n  }\r\n\r\n  _initializeRoutes() {\r\n    const self = this\r\n    this.router.get('/\\$metadata', function (req, res) {\r\n      const result = metadata(self.cfg)\r\n  \r\n      res.statusCode = 200\r\n      res.setHeader('Content-Type', 'application/xml')\r\n      res.setHeader('DataServiceVersion', '4.0')\r\n      res.setHeader('OData-Version', '4.0')\r\n      self.cfg.addCorsToResponse(res)\r\n  \r\n      return res.end(result)\r\n    })\r\n    this.router.get('/:collection/\\$count', function (req, res) {\r\n      req.params.$count = true\r\n      query(self.cfg, req, res)\r\n    })\r\n    this.router.get('/:collection\\\\(:id\\\\)', function (req, res) {\r\n      query(self.cfg, req, res)\r\n    })\r\n    this.router.get('/:collection', function (req, res) {\r\n      query(self.cfg, req, res)\r\n    })\r\n    this.router.get('/', function (req, res) {\r\n      const result = collections(self.cfg)\r\n  \r\n      res.statusCode = 200\r\n      res.setHeader('Content-Type', 'application/json')\r\n      self.cfg.addCorsToResponse(res)\r\n  \r\n      return res.end(result)\r\n    })\r\n    this.router.post('/:collection', function (req, res) {\r\n      insert(self.cfg, req, res)\r\n    })\r\n    this.router.patch('/:collection\\\\(:id\\\\)', function (req, res) {\r\n      update(self.cfg, req, res)\r\n    })\r\n    this.router.delete('/:collection\\\\(:id\\\\)', function (req, res) {\r\n      remove(self.cfg, req, res)\r\n    })\r\n  \r\n    if (this.cfg.cors) {\r\n      this.router.options('/(.*)', function (req, res) {\r\n        res.statusCode = 200\r\n        res.setHeader('Access-Control-Allow-Origin', self.cfg.cors)\r\n        res.end()\r\n      })\r\n    }\r\n  \r\n    this.router.error(function (req, res, error) {\r\n      function def (e) {\r\n        self.emit('odata-error', e)\r\n  \r\n        res.statusCode = (error.code && error.code >= 100 && error.code < 600) ? error.code : 500\r\n        res.setHeader('Content-Type', 'application/json')\r\n        self.cfg.addCorsToResponse(res)\r\n  \r\n        res.end(JSON.stringify({\r\n          error: {\r\n            code: error.code || 500,\r\n            message: e.message,\r\n            stack: e.stack,\r\n            target: req.url,\r\n            details: []\r\n          },\r\n          innererror: { }\r\n        }))\r\n      }\r\n      if (self.cfg.error) {\r\n        self.cfg.error(req, res, error, def)\r\n      } else {\r\n        def(error)\r\n      }\r\n    })\r\n  }\r\n\r\n  error(fn) {\r\n    this.cfg.error = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  query(fn) {\r\n    this.cfg.query = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  cors(domains) {\r\n    this.cfg.cors = domains\r\n    return this\r\n  }\r\n\r\n  beforeQuery(fn) {\r\n    if (fn.length === 3) {\r\n      console.warn('Listener function should accept request parameter.')\r\n      const origFn = fn\r\n      fn = function (col, query, req, cb) {\r\n        origFn(col, query, cb)\r\n      }\r\n    }\r\n  \r\n    this.cfg.beforeQuery = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  executeQuery(col, query, req, cb) {\r\n    const self = this\r\n  \r\n    this.cfg.beforeQuery(col, query, req, function (err) {\r\n      if (err) {\r\n        return cb(err)\r\n      }\r\n  \r\n      self.cfg.query(col, query, req, function (err, res) {\r\n        if (err) {\r\n          return cb(err)\r\n        }\r\n  \r\n        self.cfg.afterRead(col, res, req)\r\n        cb(null, res)\r\n      })\r\n    })\r\n  }\r\n\r\n  insert(fn) {\r\n    this.cfg.insert = fn.bind(this)\r\n    return this\r\n  }\r\n  \r\n  beforeInsert(fn) {\r\n    if (fn.length === 3) {\r\n      console.warn('Listener function should accept request parameter.')\r\n      const origFn = fn\r\n      fn = function (col, doc, req, cb) {\r\n        origFn(col, doc, cb)\r\n      }\r\n    }\r\n  \r\n    this.cfg.beforeInsert = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  executeInsert(col, doc, req, cb) {\r\n    const self = this\r\n    this.cfg.beforeInsert(col, doc, req, function (err) {\r\n      if (err) {\r\n        return cb(err)\r\n      }\r\n  \r\n      self.cfg.insert(col, doc, req, cb)\r\n    })\r\n  }\r\n\r\n  update(fn) {\r\n    this.cfg.update = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  beforeUpdate(fn) {\r\n    if (fn.length === 4) {\r\n      console.warn('Listener function should accept request parameter.')\r\n      const origFn = fn\r\n      fn = function (col, query, update, req, cb) {\r\n        origFn(col, query, update, cb)\r\n      }\r\n    }\r\n  \r\n    this.cfg.beforeUpdate = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  executeUpdate(col, query, update, req, cb) {\r\n    const self = this\r\n  \r\n    this.cfg.beforeUpdate(col, query, update, req, function (err) {\r\n      if (err) {\r\n        return cb(err)\r\n      }\r\n  \r\n      self.cfg.update(col, query, update, req, cb)\r\n    })\r\n  }\r\n\r\n  remove(fn) {\r\n    this.cfg.remove = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  beforeRemove(fn) {\r\n    if (fn.length === 3) {\r\n      console.warn('Listener function should accept request parameter.')\r\n      const origFn = fn\r\n      fn = function (col, query, req, cb) {\r\n        origFn(col, query, cb)\r\n      }\r\n    }\r\n  \r\n    this.cfg.beforeRemove = fn.bind(this)\r\n    return this\r\n  }\r\n\r\n  executeRemove(col, query, req, cb) {\r\n    const self = this\r\n    this.cfg.beforeRemove(col, query, req, function (err) {\r\n      if (err) {\r\n        return cb(err)\r\n      }\r\n  \r\n      self.cfg.remove(col, query, req, cb)\r\n    })\r\n  }\r\n\r\n  afterRead(fn) {\r\n    this.cfg.afterRead = fn\r\n    return this\r\n  }\r\n\r\n  model(model) {\r\n    this.cfg.model = model\r\n    return this\r\n  }\r\n\r\n  adapter(adapter) {\r\n    adapter(this)\r\n    return this\r\n  }\r\n\r\n  pruneResults(collection, res) {\r\n    prune(this.cfg.model, collection, res)\r\n  }\r\n\r\n  base64ToBuffer(collection, doc) {\r\n    const model = this.cfg.model\r\n    const entitySet = model.entitySets[collection]\r\n    const entityType = model.entityTypes[entitySet.entityType.replace(model.namespace + '.', '')]\r\n  \r\n    for (const prop in doc) {\r\n      if (!prop) {\r\n        continue\r\n      }\r\n  \r\n      const propDef = entityType[prop]\r\n  \r\n      if (!propDef) {\r\n        continue\r\n      }\r\n  \r\n      if (propDef.type === 'Edm.Binary') {\r\n        doc[prop] = Buffer.from(doc[prop], 'base64')\r\n      }\r\n    }\r\n  }\r\n\r\n  bufferToBase64(collection, res) {\r\n    const model = this.cfg.model\r\n    const entitySet = model.entitySets[collection]\r\n    const entityType = model.entityTypes[entitySet.entityType.replace(model.namespace + '.', '')]\r\n  \r\n    for (const i in res) {\r\n      const doc = res[i]\r\n      for (const prop in doc) {\r\n        if (!prop) {\r\n          continue\r\n        }\r\n  \r\n        const propDef = entityType[prop]\r\n  \r\n        if (!propDef) {\r\n          continue\r\n        }\r\n  \r\n        if (propDef.type === 'Edm.Binary') {\r\n          // nedb returns object instead of buffer on node 4\r\n          if (!Buffer.isBuffer(doc[prop]) && !doc[prop].length) {\r\n            let obj = doc[prop]\r\n            obj = obj.data || obj\r\n            doc[prop] = Object.keys(obj).map(function (key) { return obj[key] })\r\n          }\r\n  \r\n          // unwrap mongo style buffers\r\n          if (doc[prop]._bsontype === 'Binary') {\r\n            doc[prop] = doc[prop].buffer\r\n          }\r\n  \r\n          doc[prop] = Buffer.from(doc[prop]).toString('base64')\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  addCorsToResponse(res) {\r\n    if (this.cfg.cors) {\r\n      res.setHeader('Access-Control-Allow-Origin', this.cfg.cors)\r\n    }\r\n  }\r\n\r\n}\r\n", "import url from 'url';\r\nimport pathToRegexp from 'path-to-regexp';\r\nimport methods from 'methods';\r\n\r\nconst decode = val=>val && decodeURIComponent(val);\r\n\r\nexport class Router {\r\n  constructor(prefix) {\r\n    this.routes = {};\r\n    this.prefix = prefix === '/' ? '' : prefix;\r\n    methods.forEach(method=>this.routes[method] = []);\r\n  }\r\n\r\n  error(fn) {\r\n    this._errFn = fn;\r\n  }\r\n\r\n  dispatch(req, res) {\r\n    const m = req.method.toLowerCase()\r\n    res.odataError = (err) => this._errFn(req, res, err);\r\n  \r\n    const { pathname } = url.parse(req.originalUrl || req.url);\r\n    let match = false;\r\n  \r\n    for (const el of this.routes[m]) {\r\n      const keys = [];\r\n      const re = pathToRegexp(el.route, keys);\r\n      const ex = re.exec(pathname);\r\n  \r\n      if (!ex) { continue; }\r\n\r\n      match = true;\r\n      const args = ex.slice(1).map(decode);\r\n      req.params = {};\r\n      for (let j = 0; j < keys.length; j++) {\r\n        req.params[keys[j].name] = args[j]\r\n      }\r\n\r\n      try {\r\n        el.fn(req, res)\r\n      } catch (e) {\r\n        this._errFn(req, res, e)\r\n      }\r\n\r\n      break;\r\n    }\r\n  \r\n    if (!match) {\r\n      const error = new Error('Not Found');\r\n      error.code = 404;\r\n      res.odataError(error);\r\n    }\r\n  }\r\n}\r\n\r\nmethods.forEach(m=>{\r\n  Router.prototype[m] = function (route, fn) {\r\n    this.routes[m].push({\r\n      route: this.prefix + route,\r\n      fn\r\n    })\r\n  }\r\n});", "import { ODataServer } from \"./class/ODataServer.js\";\r\n\r\nexport default (options)=>new ODataServer(options);\r\n"],
  "mappings": ";AAAA,SAAS,oBAAoB;AAC7B,OAAOA,UAAS;AAChB,SAAS,cAAc;ACFvB,OAAO,SAAS;AAChB,OAAO,kBAAkB;AACzB,OAAO,aAAa;AAEpB,IAAM,SAAS,CAAA,QAAK,OAAO,mBAAmB,GAAG;AAE1C,IAAM,SAAN,MAAa;EAClB,YAAY,QAAQ;AAClB,SAAK,SAAS,CAAC;AACf,SAAK,SAAS,WAAW,MAAM,KAAK;AACpC,YAAQ,QAAQ,CAAA,WAAQ,KAAK,OAAO,UAAU,CAAC,CAAC;EAClD;EAEA,MAAM,IAAI;AACR,SAAK,SAAS;EAChB;EAEA,SAAS,KAAK,KAAK;AACjB,UAAM,IAAI,IAAI,OAAO,YAAY;AACjC,QAAI,aAAa,CAAC,QAAQ,KAAK,OAAO,KAAK,KAAK,GAAG;AAEnD,UAAM,EAAE,SAAS,IAAI,IAAI,MAAM,IAAI,eAAe,IAAI,GAAG;AACzD,QAAI,QAAQ;AAEZ,eAAW,MAAM,KAAK,OAAO,IAAI;AAC/B,YAAM,OAAO,CAAC;AACd,YAAM,KAAK,aAAa,GAAG,OAAO,IAAI;AACtC,YAAM,KAAK,GAAG,KAAK,QAAQ;AAE3B,UAAI,CAAC,IAAI;AAAE;MAAU;AAErB,cAAQ;AACR,YAAM,OAAO,GAAG,MAAM,CAAC,EAAE,IAAI,MAAM;AACnC,UAAI,SAAS,CAAC;AACd,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAI,OAAO,KAAK,GAAG,QAAQ,KAAK;MAClC;AAEA,UAAI;AACF,WAAG,GAAG,KAAK,GAAG;MAChB,SAAS,GAAT;AACE,aAAK,OAAO,KAAK,KAAK,CAAC;MACzB;AAEA;IACF;AAEA,QAAI,CAAC,OAAO;AACV,YAAM,QAAQ,IAAI,MAAM,WAAW;AACnC,YAAM,OAAO;AACb,UAAI,WAAW,KAAK;IACtB;EACF;AACF;AAEA,QAAQ,QAAQ,CAAA,MAAG;AACjB,SAAO,UAAU,KAAK,SAAU,OAAO,IAAI;AACzC,SAAK,OAAO,GAAG,KAAK;MAClB,OAAO,KAAK,SAAS;MACrB;IACF,CAAC;EACH;AACF,CAAC;",
  "names": ["url"]
}
